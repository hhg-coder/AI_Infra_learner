首先，确定为什么要用多线程；
单线程queue的出列入列速度非常快，可能达到GB级别；
但是实际操作中：
// 真实场景
while (running) {
    // 1. 从网络接收数据 (I/O阻塞)
    auto data = network.receive();  // 可能阻塞几毫秒
    
    // 2. 处理数据 (CPU密集)
    auto processed = heavy_computation(data);  // 可能需要几毫秒
    
    // 3. 存储到数据库 (I/O阻塞)
    database.save(processed);  // 可能阻塞几十毫秒
    
    // 队列操作只占很小一部分时间
    queue.push(processed);
}

1. I/O 阻塞问题
// 单线程：串行处理，总是在等待
┌─────────┐    ┌─────────┐    ┌─────────┐
│  网络I/O │───▶│ CPU处理 │───▶│ 磁盘I/O │  总时间：50ms
│  20ms   │    │  5ms   │    │  25ms   │
└─────────┘    └─────────┘    └─────────┘

// 多线程：并行处理，重叠I/O
线程1: │  网络I/O │───▶│ CPU │───▶│ 磁盘I/O │
线程2:      │  网络I/O │───▶│ CPU │───▶│ 磁盘I/O │
线程3:           │  网络I/O │───▶│ CPU │───▶│ 磁盘I/O │
       总吞吐量提升 3-5倍

2. 生产者-消费者模式
// 典型的多线程架构
┌──────────────┐    ┌─────────────┐    ┌──────────────┐
│   网络线程    │───▶│  无锁队列    │───▶│   处理线程    │
│ (接收数据)   │    │            │    │ (业务逻辑)   │
└──────────────┘    └─────────────┘    └──────────────┘
                           │
                           ▼
                    ┌──────────────┐
                    │   存储线程    │
                    │ (数据库写入) │
                    └──────────────┘
3. CPU 多核利用
// 现代服务器通常有多个CPU核心
Intel Xeon: 16-64 cores
AMD EPYC:   32-128 cores

// 单线程只能用1个核心 = 浪费资源
// 多线程可以充分利用所有核心


为什么选择高性能队列
即使队列操作本身很快，在高并发场景下：
// 每秒百万级操作时
moodycamel:    70M ops/s  -> 延迟: 14ns
boost:         11M ops/s  -> 延迟: 90ns  
lock-based:     3M ops/s  -> 延迟: 330ns

// 在微服务架构中，这些延迟会累积
// 70ns vs 330ns 的差异 * 1000万次调用 = 2.6秒的总延迟差异

