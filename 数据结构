一、
STL（标准模板库）中的常用容器底层数据结构如下：

vector：底层是动态数组（连续内存），支持随机访问，插入删除末尾效率高。
list：底层是双向链表，不支持随机访问，插入删除任意位置效率高。
deque：底层是分段连续内存组成的双端队列，支持高效头尾插入删除和随机访问。
stack/queue：分别基于deque或list等容器实现，属于适配器。
map/set：底层是红黑树（一种自平衡二叉搜索树），有序存储，查找、插入、删除效率为O(log n)。
unordered_map/unordered_set：底层是哈希表，查找、插入、删除平均效率为O(1)。
https://zhuanlan.zhihu.com/p/542115773
https://zhuanlan.zhihu.com/p/359878588

红黑树：
二叉查找树的缺点：极端情况下会退化成链表，这样的二叉查找树的查找时间复杂度顿时变成了 O(n)
于是我们引申出了平衡二叉树：
平衡树具有如下特点：
1、具有二叉查找树的全部特性。
2、每个节点的左子树和右子树的高度差至多等于1。
平衡树如何构建、插入、删除、左旋、右旋等操作：
那么平衡二叉树是如何构建呢，如果简单的按照排序的规则插入，那么很可能会使得二叉树不平衡，
所以为了维持树的平衡，我们在插入和删除平衡二叉树的结点时会进行一定的操作来保持平衡，
其中包括以下几种情况，以及解决方法：
左左：右旋解决
左右：先左旋再右旋
右右：左旋解决
右左：先右旋再左旋

为什么有了平衡树还需要红黑树？
虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，
不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，
导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，
使之再次成为一颗符合要求的平衡树。
如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，
为了解决这个问题，于是有了红黑树，红黑树具有如下特点：
1、具有二叉查找树的特点。
2、根节点是黑色的；
3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据。
4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。
5、每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。
平衡二叉树和红黑树的区别
平衡二叉树的左右子树的高度差绝对值不超过1，但是红黑树在某些时刻可能会超过1，只要符合红黑树的五个条件即可。
二叉树只要不平衡就会进行旋转，而红黑树不符合规则时，有些情况只用改变颜色不用旋转，就能达到平衡。
二、红黑树的构建过程
红黑树构建时要满足以上的5个规则，那么简单的插入是不够的，因为简单的插入会造成子树两边不平衡，
那么在插入时我们要进行以下两个操作，来维持红黑的规则正确：
操作1：变色
操作2：旋转
总结
所以，最后的答案是，平衡树是为了解决二叉查找树退化为链表的情况，
而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。
红黑树应用比较广泛：
1. 广泛用在C++的STL中。map和set都是用红黑树实现的。
2. 著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块。
3.epoll在内核中的实现，用红黑树管理事件块
4.nginx中，用红黑树管理timer等

