一、
STL（标准模板库）中的常用容器底层数据结构如下：

vector：底层是动态数组（连续内存），支持随机访问，插入删除末尾效率高。
list：底层是双向链表，不支持随机访问，插入删除任意位置效率高。
deque：底层是分段连续内存组成的双端队列，支持高效头尾插入删除和随机访问。
stack/queue：分别基于deque或list等容器实现，属于适配器。
map/set：底层是红黑树（一种自平衡二叉搜索树），有序存储，查找、插入、删除效率为O(log n)。
unordered_map/unordered_set：底层是哈希表，查找、插入、删除平均效率为O(1)。
https://blog.csdn.net/qq_43313035/article/details/89600276

顺序容器：
按元素​​插入顺序​​存储
底层数据结构：​	动态数组（vector）、双向链表（list）、双端队列（deque）等
典型容器​​	vector, list, deque, array, forward_list
关联容器：
元素通常按​​键（Key）排序​​（默认升序），底层数据结构：红黑树​​（一种自平衡二叉搜索树），插入、删除、查找的时间复杂度一般为 ​​O(log n)​
典型容器	set, map, multiset, multimap
无序容器：
元素​​不排序​​，存储位置由哈希函数决定
底层数据结构：哈希表​​（数组+链表/红黑树）
插入、删除、查找的​​平均​​时间复杂度为 ​​O(1)​​，最坏情况 O(n)
典型容器 unordered_set, unordered_map, unordered_multiset, unordered_multimap


二、
红黑树：
二叉查找树的缺点：极端情况下会退化成链表，这样的二叉查找树的查找时间复杂度顿时变成了 O(n)
于是我们引申出了平衡二叉树：
平衡树具有如下特点：
1、具有二叉查找树的全部特性。
2、每个节点的左子树和右子树的高度差至多等于1。
平衡树如何构建、插入、删除、左旋、右旋等操作：
那么平衡二叉树是如何构建呢，如果简单的按照排序的规则插入，那么很可能会使得二叉树不平衡，
所以为了维持树的平衡，我们在插入和删除平衡二叉树的结点时会进行一定的操作来保持平衡，
其中包括以下几种情况，以及解决方法：
左左：右旋解决
左右：先左旋再右旋
右右：左旋解决
右左：先右旋再左旋

为什么有了平衡树还需要红黑树？
虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，
不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，
导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，
使之再次成为一颗符合要求的平衡树。
如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，
为了解决这个问题，于是有了红黑树，红黑树具有如下特点：
1、具有二叉查找树的特点。
2、根节点是黑色的；
3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据。
4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。
5、每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。
平衡二叉树和红黑树的区别
平衡二叉树的左右子树的高度差绝对值不超过1，但是红黑树在某些时刻可能会超过1，只要符合红黑树的五个条件即可。
二叉树只要不平衡就会进行旋转，而红黑树不符合规则时，有些情况只用改变颜色不用旋转，就能达到平衡。

红黑树的构建过程
红黑树构建时要满足以上的5个规则，那么简单的插入是不够的，因为简单的插入会造成子树两边不平衡，
那么在插入时我们要进行以下两个操作，来维持红黑的规则正确：
操作1：变色
操作2：旋转
总结
所以，最后的答案是，平衡树是为了解决二叉查找树退化为链表的情况，
而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。
红黑树应用比较广泛：
1. 广泛用在C++的STL中。map和set都是用红黑树实现的。
2. 著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块。
3.epoll在内核中的实现，用红黑树管理事件块
4.nginx中，用红黑树管理timer等


B树和B+树：
B树的所有节点都可能存储数据，查询时可能在非叶子节点就结束。
B+树的所有数据都存储在叶子节点，非叶子节点仅作为索引。叶子节点还通过指针连接形成链表，非常适合范围查询。
B树查找过程
可以把B树想象成一个​​结构清晰、多层级的大型图书馆​​。这个图书馆的每个分馆（节点）里，不仅放着指示下一个分馆位置的指示牌（指针），还​​实际存放着一些书籍（数据）​​。
查找过程就像在这个图书馆里找一本编号特定的书（例如编号是52）：
1.从根节点（总服务台）开始​​：查看根节点里的关键字（比如40和70），52介于40和70之间，根据指示就知道要去第二个子节点（分馆）继续找。
2.​​进入内部节点（分馆）​​：在这个分馆，你看到第一个关键字是55。52小于55，所以你知道你要找的书应该在这个分馆的第一个子节点（更细的分区）里。
3.到达叶子节点（最终的书架）并查找​​：在这个最终的书架上，你遍历书架上的书号，找到了52。
4.可能的提前结束​​：​​B树的一个特点是，如果你在查找过程中，在某个非叶子节点（分馆）就正好找到了你要的关键字，
那么查找就可以直接在这里结束，不需要再往下走到叶子节点（最终的书架）​​。如果到达叶子节点还没找到，就说明这本书图书馆里没有。

B+树查找过程：
B+树则可以看作一个​​设计更加极致的现代化图书馆​​：
​​数据只存在于叶子节点​​：在B+树中，​​只有最底层的叶子节点才存储实际的数据​​，而所有非叶子节点（内节点）​​只充当索引​​，就像图书馆目录一样，告诉你该去哪个区域找，但本身没有书。
​​叶子节点串联成链​​：所有叶子节点​​通过指针连接成一个有序的双向链表​​。这个设计让范围查询变得极其高效。
查找过程（同样找编号52的书）：
1.从根节点（总索引目录）开始​​：同样，从根节点开始比较关键字，确定下一步要查找哪个子节点。
2.​逐层深入内部节点（各级索引目录）​​：这个过程和B树类似，都是在节点内比较关键字，以决定下一步前往哪个子树。​​但不同的是，B+树的非叶子节点只包含索引信息（键值），不包含实际的数据记录​​。
3.必须到达叶子节点（最终藏书室）​​：​​在B+树中，无论你要找的关键字在索引层是否出现，查找过程都必须要一直走到叶子节点才行​​。叶子节点中包含了所有的关键字和数据指针。
4.在叶子节点中查找​​：在最终的叶子节点中遍历关键字，找到52（如果存在）及其对应的数据。
​​B+树为什么范围查询快？​​
比如要找所有编号在50到60之间的书：
在B+树中，一旦在叶子节点找到了50，就可以​​顺着叶子节点的双向链表​​依次读取51, 52, ...直到60，非常高效。
在B树中，进行范围查询可能需要多次在不同的节点间来回遍历和访问，效率相对较低

查找算法与效率
B树和B+树的查找都遵循类似的高层算法：
1.​​从根节点开始​​。
2.在当前节点中查找​​：在节点内部的关键字序列中查找目标值（通常使用二分查找提升效率）。
  如果找到目标值（在B树中且在此节点命中），则查找成功。
  否则，确定目标值可能位于哪个子树的区间内。
3.​​递归或迭代地进入相应的子树​​，重复步骤2。
4.直到在B树中的某个节点命中，或到达叶子节点（在B+树中必须在叶子节点判断成功与否）。


三、哈希表
核心概念
1.键值对存储 (Key-Value Pairs)
2.哈希函数 (Hash Function):
理想要求：​​
​​确定性 (Deterministic):​​ 相同的 key必须始终产生相同的哈希值。
​​高效性 (Efficient):​​ 计算速度必须快。
​​均匀分布 (Uniform Distribution):​​ 哈希函数应尽可能地将不同的 key均匀地映射到整个可能的哈希值范围内。这是减少冲突的关键。
3.桶数组 (Bucket Array):

哈希冲突 (Hash Collision) 详解
哈希冲突是指​​两个或多个不同的键 (key) 被哈希函数映射到了同一个桶索引 (Bucket Index)​​ 上。
冲突是必然的！​​ 这是一个数学上的必然结论，被称为​​鸽巢原理 (Pigeonhole Principle)​​。
如果你有 10 个鸽巢（桶）却要放下 11 只鸽子（键），那么至少有一个鸽巢里会有不止一只鸽子。只要键的数量可能大于桶的数量，冲突就一定会发生。
因此，哈希表设计的核心不在于如何避免冲突，而在于如何​​高效地解决冲突​​。
1. 链地址法 (Separate Chaining)
原理：​​ 每个桶不再直接存储一个元素，而是存储一个​​链表 (Linked List)​​ 的头指针。所有哈希到同一个桶的元素都会被放入这个链表中。
优化：​​
当链表长度超过一定阈值（如 8）时，将链表转换为一颗​​小型平衡树 (如红黑树)​​。
这样即使冲突严重，查找时间也仅为 ​​O(log n)​​，而不是 O(n)。这是现代标准库（如 GCC, Clang）的常见优化。

2. 开放寻址法 (Open Addressing)
在这种策略中，所有元素都直接存储在桶数组本身中，没有额外的链表。当发生冲突时，它会按照某种预定的规则（“探测序列”）在数组中寻找下一个可用的空桶。
原理：​​ 遇到冲突时，使用一个​​探测函数 (Probing Function)​​ 来计算下一个候选桶的位置，直到找到一个空桶为止。
常见的探测方法：​线性探测、​​二次探测、双重散列
优点：​​
所有数据都存储在同一个数组中，​​缓存友好​​（连续内存访问）。
不需要额外的指针，​​空间开销更小​​。
缺点：​​
性能对​​负载因子 (Load Factor)​​ 非常敏感。负载因子 (α = 元素数量 / 桶数量) 必须保持在较低水平（通常 < 0.7），否则查找性能会急剧下降。
删除操作复杂，需要懒删除。
（懒删除（Lazy Deletion）是一种数据结构中的删除策略。
它的核心思想是：删除元素时，并不立即将其从数据结构中移除，而是做一个“已删除”标记，等到合适的时机再真正删除。）
表的大小是固定的（虽然可以扩容，但代价高）。






