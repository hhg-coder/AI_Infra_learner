把项目中使用到的内存池技术讲清楚：
内存池技术，主要是用来高效管理大量同类型对象的内存分配和释放，避免频繁的 new/delete 或 malloc/free，提升性能和资源利用率。
代码里的内存池原理
预分配固定数量的对象
在 MemoryPool 构造函数里，预先分配了 300 个 NetworkData 对象（T pool[PoolSize]），并把它们的指针都放进 free_list 队列。
分配对象（allocate）
当需要一个新对象时，从 free_list 队列里弹出一个指针，直接返回。这样不用每次都 new 或 malloc，速度快，碎片少。
释放对象（deallocate）
用完对象后，把指针重新放回 free_list 队列，下次可以再用。这样对象会被循环利用，避免内存泄漏和频繁分配释放。
线程安全
分配和释放都用 std::mutex 加锁，保证多线程环境下不会出错。
池耗尽处理
如果池里的对象都被分配出去了（free_list.empty()），allocate() 返回 nullptr，生产者线程会等待一会儿再尝试分配。
优点
高性能：避免频繁的系统级内存分配和释放，速度快。
低碎片：所有对象都在一块连续内存里，减少内存碎片。
易管理：对象生命周期由池统一管理，避免内存泄漏。
线程安全：适合多线程场景。


为什么要预分配预分配固定数量的对象？
预分配固定数量的对象有以下几个主要原因：
提升性能
预分配后，分配和释放对象只需操作指针队列，无需频繁调用系统的 new/delete 或 malloc/free，速度更快。
减少内存碎片
所有对象都在一块连续内存区域，避免了频繁分配释放导致的内存碎片问题。
易于管理和回收
对象统一由内存池管理，生命周期清晰，能有效防止内存泄漏。
线程安全
通过加锁保护分配和释放，适合多线程环境。
适合对象数量可预估的场景
如果你能预估最大并发需求，预分配可以保证系统稳定运行，不会因内存不足而频繁失败。
总结：
预分配固定数量对象是为了高效、稳定、可控地管理内存，特别适合高并发、对象数量可预估的场景。


这里信号量的作用是什么？
信号量 data_available 的作用是实现生产者和消费者线程之间的同步，保证：
只有当有数据可处理时，消费者线程才会被唤醒去处理数据；
生产者每生产一个数据包，就调用 signal() 增加信号量，通知消费者有新数据；
消费者线程在 wait() 处阻塞，直到信号量大于 0，才会继续处理队列中的数据。
这样可以防止消费者线程“空转”，确保每次处理的都是实际收到的数据，实现高效的线程协作。


这段代码中，虽然提前预分配了T pool[PoolSize];但是在deallocate的过程中，NetworkData不是新建的吗？
在你的代码里，NetworkData 对象不是新建的，而是从预分配的 pool 数组里“借用”的。
具体流程如下：
预分配阶段
构造 MemoryPool 时，T pool[PoolSize];（这里是 NetworkData pool[300];）会一次性分配 300 个对象在栈或堆上（取决于类的声明位置），并把每个对象的指针都放进 free_list 队列。
allocate() 分配对象
当你需要一个对象时，从 free_list 队列里弹出一个指针，返回给调用者。这个指针指向的是 pool 数组里的某个 NetworkData，不是新建的。
deallocate() 归还对象
用完对象后，把指针重新放回 free_list 队列。这样下次再用时，还是用同一个对象。
结论：
整个生命周期里，NetworkData 对象只在程序启动时分配一次，之后都是“借用”和“归还”，没有动态 new，也没有重复构造或析构。
你看到的 deallocate 只是把指针放回队列，并没有新建对象。
