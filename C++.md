一、封装、继承、多态
继承中protected继承：
 protected 方式继承后，​​基类原有的所有公有接口都不会暴露给派生类的外部使用者​​，它们只能在派生类及其后续的子类内部被使用
 protected 继承的细节与用途​​
protected 继承是一种​​实现继承​​，它强调的是对基类实现细节的复用，而非接口的延续（public 继承才是接口继承）
实现“并非是一个”的关系​​：当你希望重用基类的实现，但又不愿意在派生类中公开表达“派生类对象就是一个基类对象”的语义时（即不满足 Liskov 替换原则），可以使用 protected 继承。它​​隐藏了基类的公有接口​​，外部代码无法通过派生类的对象直接调用基类的任何方法
谨慎使用​​：protected 继承和 private 继承一样，在实际编程中​​并不常用​​。在大多数情况下，​​组合（Composition）​​（即在一个类中包含另一个类的对象作为成员变量）是比 protected/private 继承更好的代码复用方式，因为它能降低耦合度。public 继承是最常用的方式，用于建立清晰的“is-a”关系。
二、空指针、野指针、悬空指针
空指针：一般我们将等于0/NULL/nullptr的指针称为空指针。空指针不能被解引用，但是可以对空指针取地址。
int* p = nullptr;    //空指针
*p = 42;    //空指针不可以解引用
int** pp = &p    //空指针可以取地址
0/NULL/nullptr三者之间的区别：
0是int类型，NULL在g++下是一个宏定义，而nullptr是有类型的；

野指针：
野指针突出一个野字，这个野就是状态未知的。它可能指向一块未知的区域：
int* p;        //野指针，指针未初始化
*p = 42;    //对野指针解引用，未定义的操作

悬垂指针：
垂悬指针是指指针指向的内容已被释放，指针指向的对象的生命周期已结束。

三、条件变量
条件变量（condition variable）是C++标准库中用于多线程同步的一种机制，它允许一个或多个线程等待某个条件成立，直到另一个线程通知条件可能已经成立。
条件变量的基本用法：
1.
​​等待条件​​：使用std::unique_lock锁定互斥锁，然后调用条件变量的wait、wait_for或wait_until方法。这些方法会释放锁并阻塞当前线程，直到被其他线程通知（notify）且条件满足（通过传入的谓词检查或超时）。
例如，在环形缓冲区中，消费者线程等待缓冲区非空：
std::unique_lock<std::mutex> lock(mutex_);
not_empty_.wait(lock, [this]() { return count_ > 0; });
这里，wait方法会先检查条件（count_ > 0），如果条件为真，则继续执行；否则，释放锁并进入阻塞状态。当其他线程调用not_empty_.notify_one()或not_empty_.notify_all()时，线程被唤醒，并重新获取锁，然后再次检查条件。如果条件为真，则跳出等待；否则继续等待。
2.
​​通知条件​​：当某个线程改变了条件，它需要通知等待该条件变量的线程。有两种通知方式：
•notify_one()：唤醒一个等待的线程（如果有多个线程在等待，选择哪一个是不确定的）
•notify_all()：唤醒所有等待该条件变量的线程
例如，在生产者向缓冲区放入一个数据后，缓冲区不再为空，所以调用not_empty_.notify_one()来唤醒一个可能正在等待的消费者线程。

为什么需要条件变量？
在没有条件变量的情况下，线程可能需要不断轮询（polling）来检查条件，这会浪费CPU资源。条件变量允许线程在条件不满足时休眠，直到条件可能满足时被唤醒，从而节省CPU资源。
条件变量的优势
1.​​高效​​：避免了忙等待，节省CPU资源
2.线程安全​​：与互斥锁配合使用，确保操作的原子性
3.灵活性​​：可以精确控制哪些线程需要被唤醒

