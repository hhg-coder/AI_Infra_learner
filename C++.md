一、封装、继承、多态
继承中protected继承：
 protected 方式继承后，​​基类原有的所有公有接口都不会暴露给派生类的外部使用者​​，它们只能在派生类及其后续的子类内部被使用
 protected 继承的细节与用途​​
protected 继承是一种​​实现继承​​，它强调的是对基类实现细节的复用，而非接口的延续（public 继承才是接口继承）
实现“并非是一个”的关系​​：当你希望重用基类的实现，但又不愿意在派生类中公开表达“派生类对象就是一个基类对象”的语义时（即不满足 Liskov 替换原则），可以使用 protected 继承。它​​隐藏了基类的公有接口​​，外部代码无法通过派生类的对象直接调用基类的任何方法
谨慎使用​​：protected 继承和 private 继承一样，在实际编程中​​并不常用​​。在大多数情况下，​​组合（Composition）​​（即在一个类中包含另一个类的对象作为成员变量）是比 protected/private 继承更好的代码复用方式，因为它能降低耦合度。public 继承是最常用的方式，用于建立清晰的“is-a”关系。
二、空指针、野指针、悬空指针
空指针：一般我们将等于0/NULL/nullptr的指针称为空指针。空指针不能被解引用，但是可以对空指针取地址。
int* p = nullptr;    //空指针
*p = 42;    //空指针不可以解引用
int** pp = &p    //空指针可以取地址
0/NULL/nullptr三者之间的区别：
0是int类型，NULL在g++下是一个宏定义，而nullptr是有类型的；

野指针：
野指针突出一个野字，这个野就是状态未知的。它可能指向一块未知的区域：
int* p;        //野指针，指针未初始化
*p = 42;    //对野指针解引用，未定义的操作

悬垂指针：
垂悬指针是指指针指向的内容已被释放，指针指向的对象的生命周期已结束。

三、条件变量
条件变量（condition variable）是C++标准库中用于多线程同步的一种机制，它允许一个或多个线程等待某个条件成立，直到另一个线程通知条件可能已经成立。
条件变量的基本用法：
1.
​​等待条件​​：使用std::unique_lock锁定互斥锁，然后调用条件变量的wait、wait_for或wait_until方法。
这些方法会释放锁并阻塞当前线程，直到被其他线程通知（notify）且条件满足（通过传入的谓词检查或超时）。
例如，在环形缓冲区中，消费者线程等待缓冲区非空：
std::unique_lock<std::mutex> lock(mutex_);
not_empty_.wait(lock, [this]() { return count_ > 0; });
这里，wait方法会先检查条件（count_ > 0），如果条件为真，则继续执行；否则，释放锁并进入阻塞状态。
当其他线程调用not_empty_.notify_one()或not_empty_.notify_all()时，线程被唤醒，并重新获取锁，然后再次检查条件。
如果条件为真，则跳出等待；否则继续等待。
2.
​​通知条件​​：当某个线程改变了条件，它需要通知等待该条件变量的线程。有两种通知方式：
•notify_one()：唤醒一个等待的线程（如果有多个线程在等待，选择哪一个是不确定的）
•notify_all()：唤醒所有等待该条件变量的线程
例如，在生产者向缓冲区放入一个数据后，缓冲区不再为空，所以调用not_empty_.notify_one()来唤醒一个可能正在等待的消费者线程。

为什么需要条件变量？
在没有条件变量的情况下，线程可能需要不断轮询（polling）来检查条件，这会浪费CPU资源。条件变量允许线程在条件不满足时休眠，直到条件可能满足时被唤醒，从而节省CPU资源。
条件变量的优势
1.​​高效​​：避免了忙等待，节省CPU资源
2.线程安全​​：与互斥锁配合使用，确保操作的原子性
3.灵活性​​：可以精确控制哪些线程需要被唤醒

四、static和const
static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗
static
static对于变量
局部变量:
在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。
内存中的位置：data段
初始化：局部的静态变量只能被初始化一次
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）
及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。

全局变量:
在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。
内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）
初始化：未经初始化的全局静态变量会被程序自动初始化为0
作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。(只能在本文件中存在和使用)
全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。
两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。

static对于函数:
修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。
在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。（和全局变量一样限制了作用域而已）

static对于类:
成员变量:
用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。
因此，static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化 。
成员函数:
用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。
静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。
不可以同时用const和static修饰成员函数。

const
const修饰变量：限定变量为不可修改。
const修饰指针：指针常量和指向常量的指针
const和函数：有以下几种形式
const int& fun(int& a); //修饰返回值
int& fun(const int& a); //修饰形参
int& fun(int& a) const{} //const成员函数
const和类：①const修饰成员变量，在某个对象的声明周期内是常量，但是对于整个类而言是可以改变的。
因为类可以创建多个对象，不同的对象其const成员变量的值是不同的。
切记，不能在类内初始化const成员变量，因为类的对象没创建前，编译器并不知道const成员变量是什么，因此const数据成员只能在初始化列表中初始化。
②const修饰成员函数，主要目的是防止成员函数修改成员变量的值，即该成员函数并不能修改成员变量。③const对象，常对象，常对象只能调用常函数。
限定成员函数不可以修改任何数据成员

static和const可以同时修饰成员函数吗?
答：不可以。C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。
但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。两者的语意是矛盾的。
static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。
因此不能同时用它们。

五、
std::move:
move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。
如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。
所以，move对于含资源（堆内存或句柄）的对象来说更有意义。
六、
this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该非静态成员函数的那个对象。
当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。
this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。

七、函数指针类型：
函数指针类型是指用于保存函数地址的指针变量，可以通过它调用指向的函数。它允许将函数作为参数传递或存储在数据结构中。
举例说明：
假设有如下函数指针类型定义：
typedef int (*FuncPtr)(int, int);//这表示 FuncPtr 是指向“参数为两个 int，返回 int”的函数的指针类型。
使用示例1：
#include <iostream>

// 定义一个函数，签名与FuncPtr一致
int add(int a, int b) {
    return a + b;
}

int main() {
    FuncPtr func = add; // 将函数地址赋值给函数指针
    int result = func(3, 4); // 通过函数指针调用函数
    std::cout << "Result: " << result << std::endl; // 输出7
    return 0;
}
使用示例2：
typedef ParseParameterAttrStatus (*Creator)(
      const std::shared_ptr<RuntimeOperator> &op,
      std::shared_ptr<Layer> &layer);

  typedef std::map<std::string, Creator> CreateRegistry;
  这里Creator就是函数指针，就能实现函数作为参数存储在数据结构中。
  
