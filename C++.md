一、封装、继承、多态
二、空指针、野指针、悬空指针
https://zhuanlan.zhihu.com/p/640760494
空指针：一般我们将等于0/NULL/nullptr的指针称为空指针。空指针不能被解引用，但是可以对空指针取地址。
int* p = nullptr;    //空指针
*p = 42;    //空指针不可以解引用
int** pp = &p    //空指针可以取地址
0/NULL/nullptr三者之间的区别：
0是int类型，NULL在g++下是一个宏定义，而nullptr是有类型的；

野指针：
int* p;        //野指针，指针未初始化
*p = 42;    //对野指针解引用，未定义的操作

悬空指针：


三、条件变量
条件变量（condition variable）是C++标准库中用于多线程同步的一种机制，它允许一个或多个线程等待某个条件成立，直到另一个线程通知条件可能已经成立。
条件变量的基本用法：
1.
​​等待条件​​：使用std::unique_lock锁定互斥锁，然后调用条件变量的wait、wait_for或wait_until方法。这些方法会释放锁并阻塞当前线程，直到被其他线程通知（notify）且条件满足（通过传入的谓词检查或超时）。
例如，在环形缓冲区中，消费者线程等待缓冲区非空：
std::unique_lock<std::mutex> lock(mutex_);
not_empty_.wait(lock, [this]() { return count_ > 0; });
这里，wait方法会先检查条件（count_ > 0），如果条件为真，则继续执行；否则，释放锁并进入阻塞状态。当其他线程调用not_empty_.notify_one()或not_empty_.notify_all()时，线程被唤醒，并重新获取锁，然后再次检查条件。如果条件为真，则跳出等待；否则继续等待。
2.
​​通知条件​​：当某个线程改变了条件，它需要通知等待该条件变量的线程。有两种通知方式：
•notify_one()：唤醒一个等待的线程（如果有多个线程在等待，选择哪一个是不确定的）
•notify_all()：唤醒所有等待该条件变量的线程
例如，在生产者向缓冲区放入一个数据后，缓冲区不再为空，所以调用not_empty_.notify_one()来唤醒一个可能正在等待的消费者线程。

为什么需要条件变量？
在没有条件变量的情况下，线程可能需要不断轮询（polling）来检查条件，这会浪费CPU资源。条件变量允许线程在条件不满足时休眠，直到条件可能满足时被唤醒，从而节省CPU资源。
条件变量的优势
1.​​高效​​：避免了忙等待，节省CPU资源
2.线程安全​​：与互斥锁配合使用，确保操作的原子性
3.灵活性​​：可以精确控制哪些线程需要被唤醒

