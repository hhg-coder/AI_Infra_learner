一、封装、继承、多态
继承中protected继承：
 protected 方式继承后，​​基类原有的所有公有接口都不会暴露给派生类的外部使用者​​，它们只能在派生类及其后续的子类内部被使用
 protected 继承的细节与用途​​
protected 继承是一种​​实现继承​​，它强调的是对基类实现细节的复用，而非接口的延续（public 继承才是接口继承）
实现“并非是一个”的关系​​：当你希望重用基类的实现，但又不愿意在派生类中公开表达“派生类对象就是一个基类对象”的语义时（即不满足 Liskov 替换原则），可以使用 protected 继承。它​​隐藏了基类的公有接口​​，外部代码无法通过派生类的对象直接调用基类的任何方法
谨慎使用​​：protected 继承和 private 继承一样，在实际编程中​​并不常用​​。在大多数情况下，​​组合（Composition）​​（即在一个类中包含另一个类的对象作为成员变量）是比 protected/private 继承更好的代码复用方式，因为它能降低耦合度。public 继承是最常用的方式，用于建立清晰的“is-a”关系。


二、空指针、野指针、悬空指针
空指针：一般我们将等于0/NULL/nullptr的指针称为空指针。空指针不能被解引用，但是可以对空指针取地址。
int* p = nullptr;    //空指针
*p = 42;    //空指针不可以解引用
int** pp = &p    //空指针可以取地址
0/NULL/nullptr三者之间的区别：
0是int类型，NULL在g++下是一个宏定义，而nullptr是有类型的；

野指针：
野指针突出一个野字，这个野就是状态未知的。它可能指向一块未知的区域：
int* p;        //野指针，指针未初始化
*p = 42;    //对野指针解引用，未定义的操作

悬垂指针：
垂悬指针是指指针指向的内容已被释放，指针指向的对象的生命周期已结束。

三、条件变量
条件变量（condition variable）是C++标准库中用于多线程同步的一种机制，它允许一个或多个线程等待某个条件成立，直到另一个线程通知条件可能已经成立。
条件变量的基本用法：
1.
​​等待条件​​：使用std::unique_lock锁定互斥锁，然后调用条件变量的wait、wait_for或wait_until方法。
这些方法会释放锁并阻塞当前线程，直到被其他线程通知（notify）且条件满足（通过传入的谓词检查或超时）。
例如，在环形缓冲区中，消费者线程等待缓冲区非空：
std::unique_lock<std::mutex> lock(mutex_);
not_empty_.wait(lock, [this]() { return count_ > 0; });
这里，wait方法会先检查条件（count_ > 0），如果条件为真，则继续执行；否则，释放锁并进入阻塞状态。
当其他线程调用not_empty_.notify_one()或not_empty_.notify_all()时，线程被唤醒，并重新获取锁，然后再次检查条件。
如果条件为真，则跳出等待；否则继续等待。
2.
​​通知条件​​：当某个线程改变了条件，它需要通知等待该条件变量的线程。有两种通知方式：
•notify_one()：唤醒一个等待的线程（如果有多个线程在等待，选择哪一个是不确定的）
•notify_all()：唤醒所有等待该条件变量的线程
例如，在生产者向缓冲区放入一个数据后，缓冲区不再为空，所以调用not_empty_.notify_one()来唤醒一个可能正在等待的消费者线程。

为什么需要条件变量？
在没有条件变量的情况下，线程可能需要不断轮询（polling）来检查条件，这会浪费CPU资源。条件变量允许线程在条件不满足时休眠，直到条件可能满足时被唤醒，从而节省CPU资源。
条件变量的优势
1.​​高效​​：避免了忙等待，节省CPU资源
2.线程安全​​：与互斥锁配合使用，确保操作的原子性
3.灵活性​​：可以精确控制哪些线程需要被唤醒

四、static和const
static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗
static
static对于变量
局部变量:
在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。
内存中的位置：data段
初始化：局部的静态变量只能被初始化一次
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）
及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。

全局变量:
在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。
内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）
初始化：未经初始化的全局静态变量会被程序自动初始化为0
作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。(只能在本文件中存在和使用)
全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。
两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。

static对于函数:
修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。
在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。（和全局变量一样限制了作用域而已）

static对于类:
成员变量:
用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。
因此，static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化 。
成员函数:
用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。
静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。
不可以同时用const和static修饰成员函数。

const
const修饰变量：限定变量为不可修改。
const修饰指针：指针常量和指向常量的指针
const和函数：有以下几种形式
const int& fun(int& a); //修饰返回值
int& fun(const int& a); //修饰形参
int& fun(int& a) const{} //const成员函数
const和类：①const修饰成员变量，在某个对象的声明周期内是常量，但是对于整个类而言是可以改变的。
因为类可以创建多个对象，不同的对象其const成员变量的值是不同的。
切记，不能在类内初始化const成员变量，因为类的对象没创建前，编译器并不知道const成员变量是什么，因此const数据成员只能在初始化列表中初始化。
②const修饰成员函数，主要目的是防止成员函数修改成员变量的值，即该成员函数并不能修改成员变量。③const对象，常对象，常对象只能调用常函数。
限定成员函数不可以修改任何数据成员

static和const可以同时修饰成员函数吗?
答：不可以。C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。
但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。两者的语意是矛盾的。
static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。
因此不能同时用它们。

五、
std::move:
move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。
如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。
所以，move对于含资源（堆内存或句柄）的对象来说更有意义。

std::forward:
完美转发
std::forward被称为完美转发，它的作用是保持原来的值属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。
例子：
#include <iostream>

template<typename T>
void print(T & t){
    std::cout << "左值" << std::endl;
}

template<typename T>
void print(T && t){
    std::cout << "右值" << std::endl;
}

template<typename T>
void testForward(T && v){
    print(v);
    print(std::forward<T>(v));
    print(std::move(v));
}

int main(int argc, char * argv[])
{
    testForward(1);

    std::cout << "======================" << std::endl;

    int x = 1;
    testFoward(x);
}
执行结果：
左值
右值
右值
=========================
左值
左值
右值

从上面第一组的结果我们可以看到，传入的1虽然是右值，但经过函数传参之后它变成了左值（在内存中分配了空间）；而第二行由于使用了std::forward函数，所以不会改变它的右值属性，因此会调用参数为右值引用的print模板函数；第三行，因为std::move会将传入的参数强制转成右值，所以结果一定是右值。

再来看看第二组结果。因为x变量是左值，所以第一行一定是左值；第二行使用forward处理，它依然会让其保持左值，所以第二也是左值；最后一行使用move函数，因此一定是右值。
“完美转发”，也就是不改变原值的属性。

C++为什么需要完美转发？
需要完美转发的原因主要有：
保持参数的值类别（左值/右值）
有些函数（如构造函数、重载函数）对左值和右值有不同的处理方式。完美转发可以让模板函数把参数的“左值/右值”属性原封不动地传递下去，避免语义丢失。

提高效率
右值可以被移动（而不是拷贝），完美转发能让右值参数被高效地移动到目标对象，提升性能。

泛型编程的基础
在写通用库（如容器、工厂函数等）时，无法预知参数类型和数量。完美转发让这些库能灵活、高效地处理各种参数组合。

避免代码重复
如果没有完美转发，往往需要为左值和右值分别写两套重载代码，完美转发让模板代码更简洁。

典型应用场景：

容器的 emplace_back、make_shared、make_unique 等工厂函数
转发参数到其他函数或构造函数的通用接口
完美转发让C++泛型代码既高效又易维护。

六、
this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该非静态成员函数的那个对象。
当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。
this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。

七、函数指针类型：
函数指针类型是指用于保存函数地址的指针变量，可以通过它调用指向的函数。它允许将函数作为参数传递或存储在数据结构中。
举例说明：
假设有如下函数指针类型定义：
typedef int (*FuncPtr)(int, int);//这表示 FuncPtr 是指向“参数为两个 int，返回 int”的函数的指针类型。
使用示例1：
#include <iostream>

// 定义一个函数，签名与FuncPtr一致
int add(int a, int b) {
    return a + b;
}

int main() {
    FuncPtr func = add; // 将函数地址赋值给函数指针
    int result = func(3, 4); // 通过函数指针调用函数
    std::cout << "Result: " << result << std::endl; // 输出7
    return 0;
}
使用示例2：
typedef ParseParameterAttrStatus (*Creator)(
      const std::shared_ptr<RuntimeOperator> &op,
      std::shared_ptr<Layer> &layer);

  typedef std::map<std::string, Creator> CreateRegistry;
  这里Creator就是函数指针，就能实现函数作为参数存储在数据结构中。
  

八、源代码到可执行文件的流程：
源程序 (Source Code)
这是程序员编写的原始代码文件，使用高级语言如C、C++、Java等，扩展名通常为.c、.cpp、.java。它包含人类可读的算法逻辑和数据结构。
预处理器 (Preprocessor)
预处理器对源文件进行文本层面的处理，输出仍然是文本文件。它负责解析和执行所有以#开头的预处理指令。主要工作包括：包含头文件，将#include指令指定的文件内容插入到当前位置；宏替换，展开所有#define定义的宏；条件编译，根据#ifdef、#if等条件决定是否编译某部分代码；删除注释，移除源文件中的所有注释。
编译器 (Compiler)
编译器将预处理后的代码转换为汇编语言。这个过程包括多个阶段：词法分析，将代码字符流分解成有意义的词法单元；语法分析，根据语法规则构建抽象语法树；语义分析，进行类型检查和变量声明验证；代码优化和生成，对中间代码进行优化并生成目标平台的汇编代码。
汇编程序 (Assembler)
汇编器将汇编代码翻译成机器可执行的二进制机器码，输出目标文件。它解析汇编指令，生成对应的二进制机器码，并生成符号表记录函数和变量的地址信息。
目标程序 (Object Code)
这是汇编器的输出文件，包含机器码、数据段和符号表。它是二进制格式但还不能直接执行，因为多个目标文件之间可能存在未解析的引用。
连接器 (Linker)
链接器将多个目标文件和库文件合并成可执行文件。主要功能包括：符号解析，解决跨文件间的函数和变量引用；重定位，为所有代码和数据分配最终内存地址并修正引用地址；合并代码段和数据段。
可执行程序 (Executables)
这是编译过程的最终产物，包含完整的机器指令、初始化数据和程序入口地址。操作系统可以将其加载到内存中直接执行。


九、虚函数表是共享的还是独有的？
虚函数表是针对类的，一个类的所有对象的虚函数表都一样。在gcc编译器的实现中虚函数表vtable存放在可执行文件的只读数据段.rodata中。是编译器在编译器为我们处理好的。
同理，类的成员函数也是共享的，​​类中定义的普通成员函数（非静态成员函数）也是被该类的所有对象共享的​​，这和虚函数表（vtable）的共享理念一脉相承，都体现了面向对象中“数据与行为分离”的核心原则。
当对象调用成员函数时，编译器会隐式地传入一个指向当前对象的this指针。
这样，虽然函数代码是共享的，但通过this指针可以区分不同的对象实例并访问其各自的成员变量。
静态成员函数，它们也是共享的，但没有this指针，因此不能直接访问非静态成员变量


十、new/delete
new 实际上会调用 operator new，它默认调用 malloc（C 库函数）。
delete 实际上会调用 operator delete，它默认调用 free（C 库函数）。
void* operator new(size_t size) {
    return malloc(size); // 实际调用C库的malloc
}
void operator delete(void* ptr) noexcept {
    free(ptr); // 实际调用C库的free
}

new = 申请内存（operator new → malloc）+ 调用构造函数
释放时，delete 会先调用析构函数，再释放内存（operator delete → free）

delete p; 的底层原理如下（假设 p 是通过 new 分配的指针）：
调用析构函数
首先，delete p; 会调用指针 p 所指向对象的析构函数（p->~A()），用于清理对象资源。
释放内存
析构函数调用完成后，delete 会调用全局的 operator delete，将 p 指向的内存块释放。
默认情况下，operator delete 会调用 C 标准库的 free 函数。
伪代码：
if (p != nullptr) {
    p->~A();                  // 1. 调用析构函数
    operator delete(p);       // 2. 释放内存（通常调用free）
}


十一、关于函数参数是指针的问题
比如sort(Node* head);如果head本身在函数中被更改，那么函数外head会变吗？
答案是不会：
对于函数 sort(Node* head)，如果函数内部改变了 head指针本身，​​函数外的 head不会被改变​​。但如果改变了 head指向的节点内容，那么函数外会看到这些变化。
1. 指针传递的本质
当您传递 Node* head给函数时，实际上传递的是指针的​​副本​​（即内存地址的副本）。这意味着：
函数内可以修改指针指向的内容（节点的值、next指针等）
但函数内修改指针本身（让它指向别处）不会影响函数外的指针
void modifyContent(Node* head) {
    // 这会改变函数外看到的节点内容
    head->val = 100;
    head->next = someOtherNode;
}

void modifyPointer(Node* head) {
    // 这不会影响函数外的指针
    head = someOtherNode; // 只改变了函数内的副本
}

void modifyPointerWithReference(Node*& head) {
    // 这会改变函数外的指针（使用引用）
    head = someOtherNode;
}

void modifyPointerWithDoublePointer(Node** head) {
    // 这会改变函数外的指针（使用指针的指针）
    *head = someOtherNode;
}


十二、constexpr
constexpr 让变量或函数的值在编译期就能确定。
常用于数组长度、模板参数、编译期计算等场景。
能提升性能，减少运行时计算。
constexpr int square(int x) {
    return x * x;
}
int main() {
    int arr[square(3)]; // 等价于 int arr[9];
}

十三、虚函数
​​重写虚函数​​: 表现出多态行为。通过​​基类指针或引用​​调用时，实际调用的是​​指针/引用所指向的对象的实际类型（派生类）​​ 的版本。这就是“动态绑定”或“晚绑定”，函数调用在运行时决定。
​​重写非虚函数​​: ​​不​​表现出多态行为。通过基类指针或引用调用时，调用的是​​指针/引用本身的类型（基类）​​ 的版本。这是“静态绑定”或“早绑定”，函数调用在编译时就已经确定。
