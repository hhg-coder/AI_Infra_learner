https://xiaoweichen.github.io/Hands-On-Design-Patterns-with-Cpp/chapter12.2..html

/*
C++ 友元（Friend）详解

1. 基本概念
友元是 C++ 提供的一种突破类封装性的机制，允许特定的外部函数或类访问当前类的私有(private)和保护(protected)成员。
关键字：friend

2. 核心特性
- 单向性：A 是 B 的友元 ≠ B 是 A 的友元
- 非传递性：A 是 B 的友元，B 是 C 的友元 ≠ A 是 C 的友元
- 不继承：基类的友元不会成为派生类的友元

3. 三种友元类型
*/

// 3.1 友元函数
class BankAccount {
private:
    double balance;
public:
    BankAccount(double amt) : balance(amt) {}
    
    // 声明友元函数（可访问私有成员）
    friend void displayBalance(const BankAccount& account);
};

// 友元函数实现（无需 BankAccount:: 限定）
void displayBalance(const BankAccount& account) {
    std::cout << "Balance: $" << account.balance;  // 直接访问私有成员
}

// 3.2 友元类
class Sensor {
private:
    int rawData;
public:
    Sensor(int data) : rawData(data) {}
    
    // 声明友元类
    friend class DataProcessor;
};

class DataProcessor {
public:
    void process(Sensor& sensor) {
        sensor.rawData *= 2;  // 直接访问 Sensor 的私有成员
    }
};

// 3.3 友元成员函数
class Engine {
private:
    int rpm;
public:
    Engine(int speed) : rpm(speed) {}
    
    // 声明特定类的成员函数为友元
    friend class Car::startEngine;  // 仅 Car 类的 startEngine 方法可访问
};

class Car {
public:
    void startEngine(Engine& eng) {
        eng.rpm = 1000;  // 直接访问 Engine 的私有成员
    }
};

/*
4. 使用场景
- 运算符重载（特别是 <<, >>）
- 需要跨类访问私有数据的工具函数
- 紧密耦合的类（如树节点和树类）
- 单元测试中访问私有成员

5. 典型示例：运算符重载
*/
class Complex {
private:
    double real, imag;
public:
    Complex(double r, double i) : real(r), imag(i) {}
    
    // 声明友元运算符函数
    friend Complex operator+(const Complex& a, const Complex& b);
    friend std::ostream& operator<<(std::ostream& os, const Complex& c);
};

Complex operator+(const Complex& a, const Complex& b) {
    return Complex(a.real + b.real, a.imag + b.imag);
}

std::ostream& operator<<(std::ostream& os, const Complex& c) {
    os << "(" << c.real << " + " << c.imag << "i)";
    return os;
}

/*
6. 注意事项
- 谨慎使用：过度使用会破坏封装性
- 声明位置：可在类的任意部分声明（private/public 区域均可）
- 前向声明：使用前需要完整定义或前向声明
- 不可继承：派生类不能继承基类的友元关系
- 不可传递：友元的友元不是你的友元

7. 友元 vs 成员函数
| 特性               | 友元函数                     | 成员函数                   |
|--------------------|-----------------------------|---------------------------|
| 访问权限           | 需显式声明                   | 自动拥有访问权            |
| 调用方式           | 常规函数调用(obj + obj2)     | 对象调用(obj.operator())  |
| 左操作数类型       | 可自由定义                   | 必须是类对象              |
| 对称操作符实现     | ✅ 更自然                   | ❌ 受限                   |

8. 最佳实践
- 优先使用成员函数，仅在必要时使用友元
- 运算符重载中，<< 和 >> 通常实现为友元
- 保持友元关系最小化（仅暴露必要部分）
- 在头文件中声明，在源文件中实现
- 添加详细注释说明友元关系的必要性

9. 高级用法：友元模板
*/
template <typename T>
class Container {
private:
    T* data;
    int size;
public:
    // 模板类作为友元
    template <typename U>
    friend class ContainerPrinter;
};

template <typename U>
class ContainerPrinter {
public:
    void print(const Container<U>& c) {
        for (int i = 0; i < c.size; ++i)  // 访问私有成员
            std::cout << c.data[i] << " ";
    }
};

/*
10. 重要结论
友元机制是 C++ 封装性的"后门"，应在以下情况使用：
- 运算符重载需要访问私有数据时
- 两个类需要紧密协作但不应合并时
- 需要为类创建特殊工具函数时
- 单元测试需要访问私有成员时
*/
