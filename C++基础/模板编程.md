1. 函数模板
定义：用于生成可以处理不同类型的函数代码。
#include <iostream>
template<typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add(1, 2) << std::endl;       // 输出 3
    std::cout << add(1.5, 2.5) << std::endl;   // 输出 4.0
}

2. 类模板
定义：用于生成可以处理不同类型的类代码。
template<typename T>
class Box {
public:
    T value;
    Box(T v) : value(v) {}
};

int main() {
    Box<int> b1(10);
    Box<double> b2(3.14);
}

3. 模板特化
定义：为特定类型提供模板的特殊实现。
template<typename T>
class Printer {
public:
    void print(T value) {
        std::cout << value << std::endl;
    }
};

// 特化：针对 const char* 类型
template<>
class Printer<const char*> {
public:
    void print(const char* value) {
        std::cout << "字符串: " << value << std::endl;
    }
};

4. 变参模板
定义：可以接受任意数量参数的模板。
#include <iostream>

template<typename... Args>
void printAll(Args... args) {
    (std::cout << ... << args) << std::endl; // C++17 折叠表达式
}

int main() {
    printAll(1, " + ", 2, " = ", 3);
}

5. 模板元编程（TMP）与类型萃取（type traits）
定义：在编译期进行计算和类型推断的技术。
类型萃取：用于获取类型信息的模板结构体。
#include <type_traits>
#include <iostream>

template<typename T>
void checkType() {
    if (std::is_integral<T>::value)
        std::cout << "是整型" << std::endl;
    else
        std::cout << "不是整型" << std::endl;
}

int main() {
    checkType<int>();      // 输出 是整型
    checkType<double>();   // 输出 不是整型
}
