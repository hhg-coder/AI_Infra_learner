1. 函数模板
定义：用于生成可以处理不同类型的函数代码。
#include <iostream>
template<typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add(1, 2) << std::endl;       // 输出 3
    std::cout << add(1.5, 2.5) << std::endl;   // 输出 4.0
}

2. 类模板
定义：用于生成可以处理不同类型的类代码。
template<typename T>
class Box {
public:
    T value;
    Box(T v) : value(v) {}
};

int main() {
    Box<int> b1(10);
    Box<double> b2(3.14);
}

3. 模板特化
定义：为特定类型提供模板的特殊实现。
template<typename T>
class Printer {
public:
    void print(T value) {
        std::cout << value << std::endl;
    }
};

// 特化：针对 const char* 类型
template<>
class Printer<const char*> {
public:
    void print(const char* value) {
        std::cout << "字符串: " << value << std::endl;
    }
};

4. 变参模板
定义：可以接受任意数量参数的模板。
#include <iostream>

template<typename... Args>
void printAll(Args... args) {
    (std::cout << ... << args) << std::endl; // C++17 折叠表达式
}

int main() {
    printAll(1, " + ", 2, " = ", 3);
}

5. 模板元编程（TMP）与类型萃取（type traits）
定义：在编译期进行计算和类型推断的技术。
类型萃取：用于获取类型信息的模板结构体。
#include <type_traits>
#include <iostream>

template<typename T>
void checkType() {
    if (std::is_integral<T>::value)
        std::cout << "是整型" << std::endl;
    else
        std::cout << "不是整型" << std::endl;
}

int main() {
    checkType<int>();      // 输出 是整型
    checkType<double>();   // 输出 不是整型
}

std::pair是 C++ 标准模板库（STL）中一个非常基础且实用的组件，定义在 <utility>头文件中。它的核心思想是​​将一个可能不同类型的值组合成一个单一的、可管理的单元​​。
核心底层原理
std::pair的本质是一个​​模板类（Template Class）​​，其底层实现可以简单地理解为包含两个公有（public）数据成员的结构。
伪代码：
namespace std {
    template <typename T1, typename T2>
    struct pair {
        // 成员变量（公开的，可直接访问）
        T1 first;
        T2 second;

        // 构造函数
        // 1. 默认构造函数：值初始化（对于内置类型，通常是未定义的，但C++11后为“零初始化”）
        pair();
        // 2. 接收两个参数的构造函数
        pair(const T1& x, const T2& y);
        // 3. 移动构造函数 (C++11 引入)
        pair(T1&& x, T2&& y);
        // 4. 拷贝/移动构造函数
        pair(const pair&) = default;
        pair(pair&&) = default;

        // 赋值运算符
        pair& operator=(const pair& other);
        // ... 以及其他构造函数，如从其他可转换类型的pair构造

        // 交换函数
        void swap(pair& other);
    };
}
内存布局
在内存中，一个 std::pair对象通常就是其两个成员 first和 second顺序排列所占用的空间，可能加上编译器为了内存对齐（Alignment）而插入的填充字节（Padding）。




