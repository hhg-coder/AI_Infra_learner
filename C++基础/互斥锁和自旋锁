核心概念
​​互斥锁 (Mutex)​​
​​工作原理​​：当线程尝试获取一个已被其他线程占用的互斥锁时，该线程会被​​阻塞​​（Blocked），并让出 CPU 给其他线程。线程会进入睡眠状态，等待锁被释放时由操作系统唤醒。
​​类比​​：就像在厕所门外等待。发现门锁着，你不会一直盯着门把手，而是去旁边的沙发上睡觉。等里面的人出来把你叫醒，你再进去。
​​自旋锁 (Spinlock)​​
​​工作原理​​：当线程尝试获取一个已被占用的自旋锁时，线程不会让出 CPU，而是会在一个​​循环中不断地检查​​锁是否已被释放（即“自旋”）。
​​类比​​：就像在厕所门外等待。发现门锁着，你就不停地用手去拧门把手，直到能拧开为止。在这个过程中，你什么都没干，只是在不停地尝试。

  如何选择？
遵循一个简单的原则：
​​默认使用 std::mutex​​。在绝大多数情况下，它都是最安全、性能表现最好的选择，因为操作系统调度器能高效地管理线程的睡眠和唤醒。
​​只有在你非常确定临界区代码极短（通常是几条原子指令），且是多核环境，并且性能分析表明互斥锁成为瓶颈时​​，才考虑使用自旋锁。
​​内核开发​​或​​底层高性能库​​（如数据库、JVM）中常见自旋锁。
​​应用程序开发​​中很少需要自己实现和使用自旋锁。
​​错误选择的风险​​：
​​在长临界区使用自旋锁​​：会严重浪费 CPU 资源，降低系统整体性能。
​​在单核CPU上使用自旋锁​​：会导致死锁。
  为什么单核会死锁？
问题的根源在于自旋锁的 ​​“忙等待”（Busy-Waiting）​​ 机制与​​单核CPU的单一执行能力​​不兼容。
​​自旋锁的假设​​：持有锁的线程​​正在另一个CPU核心上运行​​，并且​​很快​​就会释放锁。所以“稍微等一下”是值得的，避免了上下文切换的开销。
​​单核CPU的现实​​：只有一个执行核心。如果一个线程在等待锁，那么​​持有锁的线程根本不可能同时运行​​。等待线程的“自旋”完全是徒劳的，它只是在阻止那个唯一能解决问题的线程（持有锁的线程）运行。
