移动语义的底层原理
右值引用（T&&）
C++11引入右值引用，允许函数接受临时对象（右值），从而“窃取”其资源。

std::move
std::move本质上是一个类型转换，把对象强制转换为右值引用（T&&），使其可以被移动构造/赋值函数接收。

移动构造/赋值函数
你需要自定义或使用编译器生成的移动构造函数和移动赋值运算符。它们通常通过“资源指针转移+原对象置空”实现资源的高效转移。

本质：
移动语义通过右值引用和std::move，让资源的所有权在对象间转移，而不是复制。

完美转发的底层原理
模板参数的引用折叠（Reference Collapsing）
当模板参数为T&&时，传入左值会折叠为T&，传入右值为T&&。这就是“转发引用”（Forwarding Reference）。

std::forward
std::forward<T>(arg)根据T的类型（左值/右值），把参数“原封不动”地转发给下一级函数，保持其值类别。

本质：
完美转发依赖于模板参数推导和引用折叠机制，通过std::forward保证参数的左值/右值属性不变，实现泛型代码的高效转发。

总结
移动语义：右值引用 + std::move + 移动构造/赋值函数，实现资源所有权转移。
完美转发：模板参数推导 + 引用折叠 + std::forward，实现参数值类别的无损转发。

#include <iostream>
void process(int& x) { std::cout << x << "左值\n"; }
void process(int&& x) { std::cout << x << "右值\n"; }

template<typename T>
void forwarder(T&& arg) {
    process(std::forward<T>(arg));
}

int main() {
    int a = 5;
    forwarder(a);      // 输出：左值
    forwarder(10);     // 输出：右值
}
