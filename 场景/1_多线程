
一、基础概念与线程管理
这类问题考察对多线程基本概念的理解和线程生命周期的管理。
​​1. 创建线程的几种方式？​​
​​答案要点​​：
使用函数指针：std::thread t1(func, arg1, arg2);
使用Lambda表达式：std::thread t2([](){ ... });
使用函数对象（仿函数）：定义一个重载了operator()的类，然后传入该类的实例。
使用成员函数：需要传入函数地址和对象实例：std::thread t3(&MyClass::func, &obj, arg1);
​​2. std::thread对象在什么情况下会抛出异常？​​
​​答案要点​​：
最常见的情况是​​无法启动新的线程​​（例如，系统资源耗尽）。
在构造std::thread对象时，如果提供的参数无法被复制或移动到线程的内部存储中，也可能导致编译错误或异常。
​​关键​​：std::thread的析构函数要求线程必须是joinable() == false（即已调用join()或detach()），否则会调用std::terminate()终止程序，这比异常更严重。

3. join()和 detach()的区别？​​
​​join()​​：阻塞当前主线程，等待被join的线程执行完毕，然后主线程再继续执行。它负责清理该线程的资源。一个线程只能被join一次。
​​detach()​​：将子线程从主线程中分离，使其成为​​守护线程​​（后台线程）。分离后，主线程无法再与之交互，其资源在线程结束后由运行时库自动回收。一旦分离，就无法再join。
​​核心原则​​：在std::thread对象析构前，必须决定是join还是detach，否则程序会异常终止。

二、数据同步与竞态条件
这是多线程面试的核心，几乎必考。
​​4. 什么是数据竞争？如何避免？​​
​​数据竞争​​：当多个线程在没有同步的情况下，并发读写​​同一块内存​​，且至少有一个是​​写​​操作时，就会发生数据竞争。其结果未定义（程序可能崩溃、产生错误结果或表现正常）。
​​如何避免​​：
使用互斥量（std::mutex）保护共享数据。
使用原子操作（std::atomic）。
通过设计确保每个数据只被一个线程访问（例如线程本地存储thread_local）。

​5. 编写一个经典的生产者-消费者模型。​​
​​场景​​：一个或多个生产者线程生产数据，一个或多个消费者线程消费数据。它们通过一个共享的、有大小限制的队列进行通信。
​​同步需求​​：
当队列​​满​​时，生产者必须等待（阻塞）。
当队列​​空​​时，消费者必须等待（阻塞）。
对队列的访问必须是互斥的。

​6. 解释一下死锁及其产生的四个必要条件。如何预防死锁？​​
​​死锁​​：两个或多个线程互相等待对方持有的资源，导致所有线程都无法继续执行。
​​四个必要条件​​（缺一不可）：
​​互斥​​：资源一次只能被一个线程占用。
​​占有并等待​​：线程已持有至少一个资源，又在等待其他资源。
​​不可剥夺​​：线程已获得的资源在未使用完之前不能被强行抢占。
​​循环等待​​：存在一个线程-资源的环形等待链（T1等T2占有的资源，T2等T1占有的资源）。

预防策略​​：
​​避免嵌套锁​​：尽量不要在持有一个锁的情况下去获取另一个锁。如果不可避免，则使用std::lock()或std::scoped_lock（C++17）来​​一次性锁住多个互斥量​​，避免因加锁顺序不一致导致的死锁。
​​固定加锁顺序​​：如果必须嵌套锁，所有线程都按照​​相同的全局顺序​​获取锁。
​​使用RAII​​：如std::lock_guard, std::unique_lock，确保锁在退出作用域时一定能被释放。

