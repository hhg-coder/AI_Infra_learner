1. 简单结构体直接拷贝
// 结构体定义
struct Person {
    int age;
    char name[32];
};

// 写入共享内存
Person p = {18, "Tom"};
memcpy(shm_buf, &p, sizeof(p)); // 直接拷贝到共享内存

// 读取共享内存
Person q;
memcpy(&q, shm_buf, sizeof(q)); // 从共享内存还原
printf("age=%d, name=%s\n", q.age, q.name);


2. 复杂数据（如vector<string>）手动序列化/反序列化
#include <vector>
#include <string>
#include <cstring>

// 假设共享内存大小足够
char* shm_buf = ...;

// 序列化写入
std::vector<std::string> vec = {"hello", "world", "C++"};
size_t offset = 0;
size_t n = vec.size();
memcpy(shm_buf + offset, &n, sizeof(n)); // 写入元素个数
offset += sizeof(n);
for (const auto& s : vec) {
    size_t len = s.size();
    memcpy(shm_buf + offset, &len, sizeof(len)); // 写入字符串长度
    offset += sizeof(len);
    memcpy(shm_buf + offset, s.data(), len);     // 写入字符串内容
    offset += len;
}

// 反序列化读取
offset = 0;
size_t m = 0;
memcpy(&m, shm_buf + offset, sizeof(m)); // 读取元素个数
offset += sizeof(m);
std::vector<std::string> vec2;
for (size_t i = 0; i < m; ++i) {
    size_t len = 0;
    memcpy(&len, shm_buf + offset, sizeof(len)); // 读取字符串长度
    offset += sizeof(len);
    std::string s(shm_buf + offset, len);       // 读取字符串内容
    offset += len;
    vec2.push_back(s);
}
// 验证
for (auto& s : vec2) printf("%s\n", s.c_str());



3. 使用第三方序列化库（如protobuf）
// 假设已用protobuf定义了Person消息
PersonMsg msg;
msg.set_age(18);
msg.set_name("Tom");
std::string out;
msg.SerializeToString(&out); // 序列化为字节流
memcpy(shm_buf, out.data(), out.size()); // 写入共享内存

// 读取
PersonMsg msg2;
msg2.ParseFromArray(shm_buf, out.size()); // 反序列化
printf("age=%d, name=%s\n", msg2.age(), msg2.name().c_str());



/***
Q : 什么情况需要序列化？
vector<int> 这类 STL 容器在进程间通过共享内存传递时通常需要序列化。
为什么 vector<int> 需要序列化？
std::vector<int> 在内存中的布局包含指针、容量等元数据，不同进程的虚拟地址空间不同，直接 memcpy 过去，另一个进程无法正确识别和访问数据。
只有纯POD类型（Plain Old Data，如int、float、简单结构体）且没有指针成员，才能直接 memcpy。
STL容器、类对象、含指针的结构体等，都需要序列化（即转换为连续的字节流），对方进程才能正确还原。
需要序列化的条件
数据结构中包含指针、引用、虚函数、动态分配内存等。
STL容器（如vector、map、string等）。
复杂自定义类或结构体。
不需要序列化的条件
仅包含基础类型（int、float、char等）或无指针的简单结构体，可以直接 memcpy。
总结：
只要数据结构中有指针或是STL容器、复杂对象，都需要序列化为字节流后再写入共享内存，否则接收进程无法正确还原数据。
*/
