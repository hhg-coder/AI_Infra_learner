1、
​​典型案例​​：在开发一个实时目标跟踪模块时，​​数据处理线程​​会定期更新一个共享的目标列表，而​​显示线程​​则需要读取这个列表来刷新界面。
曾出现过在显示线程读取目标列表的过程中（例如刚读完一半），数据处理线程突然修改了列表（如删除了一个目标），
导致显示线程读到的数据​​前后不一致​​，进而引发界面显示错乱或程序崩溃。
​​我们的解决方案​​：
​​核心：锁机制​​。我们立即为这个共享的目标列表加上了一个互斥锁（std::mutex）。任何线程在访问（读或写）该列表前都必须先获取锁，操作完成后立即释放
。这确保了任一时刻只有一个线程能操作列表。
​​优化读写比例​​：由于显示线程（读操作）的频率远高于数据处理线程（写操作），我们后期将互斥锁升级为​​读写锁（std::shared_mutex）​​
。这允许多个读线程并发访问，大大提高了显示帧率，只有在写操作时才需要独占资源。

lock()和unlock()
尽量用lock_guard这些raii思想的写法
lock()和unlock()在lock()后抛出异常的话没有，unlock()会导致死锁

2、
实现自定义的内存池（Memory Pool）​​：为了避免频繁地向系统申请和释放内存（malloc/new, free/delete）所带来的性能抖动和碎片问题，我们实现了线程安全的内存池。
数据处理单元（如雷达脉冲数据块）都从内存池中预分配和复用。这极大地提高了内存分配的效率，并保证了程序的确定性（Deterministic）。
利用现代C++特性实现资源自动管理​​：我们大量使用智能指针（如std::unique_ptr配合自定义删除器来管理内存池中的对象）、RAII机制来管理资源（如文件句柄、网络连接），
从而极大地减少了资源泄漏的风险，让代码更健壮、更清晰。
异常安全​​：即使处理过程中抛出异常，栈回滚也会确保unique_ptr被销毁，从而触发删除器归还内存，资源不会泄漏。
​​在复杂的多线程C++系统中，绝对不要轻易在线程间传递裸指针及其所有权。​​ 必须使用像智能指针这样的RAII工具，并精心设计资源管理策略（如对象池），将资源的生命周期管理与业务逻辑彻底解耦，才能构建出既高性能又高可靠性的系统。


3、
线上排查死锁或者CPU占用异常的问题
gdb附着对应进程，配合源代码排查
计算逻辑问题还是线程死锁抑或是网络i/o问题

4、
数据处理的挑战
挑战​​：雷达信号处理要求数据块​​严格有序​​。但由于我们使用了​​线程池​​，多个处理线程可能并行处理不同时间窗的数据。
如果线程调度顺序不确定，可能导致较早的数据反而比较晚的数据更晚完成处理，破坏了时序。
解决方案​​：我们实现了一个 ​​“顺序提交器”​​。
每个数据块都有一个单调递增的​​序列号​​。
处理线程完成计算后，并不直接放入下游队列，而是将结果（及其序列号）提交给一个单线程管理的​​优先级队列​​（最小堆）。
​​提交器线程​​检查堆顶元素的序列号。如果正是下一个期待的顺序号，就将其弹出并发送到下游队列。如果不是，就等待。
这样，即使处理线程是乱序完成的，提交器也能保证结果的有序输出，代价是引入了一个单线程瓶颈和少量延迟。
