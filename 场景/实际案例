1、
​​典型案例​​：在开发一个实时目标跟踪模块时，​​数据处理线程​​会定期更新一个共享的目标列表，而​​显示线程​​则需要读取这个列表来刷新界面。
曾出现过在显示线程读取目标列表的过程中（例如刚读完一半），数据处理线程突然修改了列表（如删除了一个目标），
导致显示线程读到的数据​​前后不一致​​，进而引发界面显示错乱或程序崩溃。
​​我们的解决方案​​：
​​核心：锁机制​​。我们立即为这个共享的目标列表加上了一个互斥锁（std::mutex）。任何线程在访问（读或写）该列表前都必须先获取锁，操作完成后立即释放
。这确保了任一时刻只有一个线程能操作列表。
​​优化读写比例​​：由于显示线程（读操作）的频率远高于数据处理线程（写操作），我们后期将互斥锁升级为​​读写锁（std::shared_mutex）​​
。这允许多个读线程并发访问，大大提高了显示帧率，只有在写操作时才需要独占资源。

2、
lock()和unlock()
尽量用lock_guard这些raii思想的写法
lock()和unlock()在lock()后抛出异常的话没有，unlock()会导致死锁

3、
实现自定义的内存池（Memory Pool）​​：为了避免频繁地向系统申请和释放内存（malloc/new, free/delete）所带来的性能抖动和碎片问题，我们实现了线程安全的内存池。
数据处理单元（如雷达脉冲数据块）都从内存池中预分配和复用。这极大地提高了内存分配的效率，并保证了程序的确定性（Deterministic）。
利用现代C++特性实现资源自动管理​​：我们大量使用智能指针（如std::unique_ptr配合自定义删除器来管理内存池中的对象）、RAII机制来管理资源（如文件句柄、网络连接），
从而极大地减少了资源泄漏的风险，让代码更健壮、更清晰。
异常安全​​：即使处理过程中抛出异常，栈回滚也会确保unique_ptr被销毁，从而触发删除器归还内存，资源不会泄漏。

4、
