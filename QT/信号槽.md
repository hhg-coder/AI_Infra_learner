一、信号和槽机制

信号和槽用于两个对象之间的通信，信号和槽机制是Qt的核心特征，也是Qt不同于其他开发框架的最突出的特征。
在GUI编程中，当改变了一个部件时，总希望其他部件也能了解到该变化。更一般来说，我们希望任何对象都可以和其他对象进行通信。

信号槽是 Qt 独创的一种​​对象间通信机制​​，用于替代传统的回调函数（如 C++ 中的函数指针、Java 中的监听器），它更加​​类型安全、松散耦合、灵活强大​​。

底层原理：
信号槽机制的实现依赖于 Qt 的三大基石：​​元对象系统 (Meta-Object System)​​、​​moc (Meta-Object Compiler)​​ 和​​事件循环 (Event Loop)​​。
信号槽机制的实现依赖于 Qt 的三大基石：​​元对象系统 (Meta-Object System)​​、​​moc (Meta-Object Compiler)​​ 和​​事件循环 (Event Loop)​​。
1. 元对象系统 (Meta-Object System)
Qt 通过元对象系统为 C++ 增加了​​内省（Introspection）​​ 和​​动态调用​​的能力。任何想使用信号槽的类都必须：
继承自 QObject
在类声明中包含 Q_OBJECT宏
Q_OBJECT宏会为类声明一系列用于内省的成员函数和静态元对象信息，例如：
metaObject(): 返回类的元对象。
qt_metacall(): 用于动态调用信号、槽、属性等。
2. moc (元对象编译器)
这是实现魔法的最关键一步。moc是一个预处理器，它会在 C++ 编译器之前运行。
​​moc 的工作流程：​​
当你编译项目时，qmake或 cmake会扫描头文件。
找到包含 Q_OBJECT宏的类，moc会为这些类生成一个 moc_ClassName.cpp的源文件。
这个生成的文件包含了​​信号的实现代码​​、​​元对象信息（字符串形式的类名、信号名、槽名）​​ 以及用于动态调用的函数表。
​​moc 为信号做了什么？​​
当你声明一个信号 void mySignal(int value);时，moc会为你生成一个类似下面的函数：
// 在 moc_MyClass.cpp 中 (自动生成)
void MyClass::mySignal(int value)
{
    // 1. 内部会调用 QMetaObject::activate(...)
    // 2. activate 函数会去查询这个对象的所有连接（connections）
    // 3. 找到所有连接到 mySignal 的槽函数，并依次调用它们
    QMetaObject::activate(this, &staticMetaObject, signalIndex, &value);
}
所以，当你 emit mySignal(10);时，你实际上是在调用这个由 moc生成的函数。
3. 连接的管理与执行
​​连接存储​​： 每个 QObject实例都有一个连接列表，记录着所有连接到它的信号以及目标对象和槽的信息。
​​执行流程​​：
你调用 emit someSignal()。
调用由 moc生成的 someSignal()函数。
这个函数调用 QMetaObject::activate(...)。
activate查找连接列表，找到所有与该信号连接的槽函数。
根据​​连接类型​​，决定如何调用这些槽函数。
4. 连接类型与线程模型
这是信号槽机制如此强大的关键。QObject::connect的第五个参数可以指定连接类型：
​​Qt::AutoConnection (默认)​​： 自动判断。如果发送者和接收者在​​同一线程​​，则使用 DirectConnection；如果在​​不同线程​​，则使用 QueuedConnection。
​​Qt::DirectConnection​​： ​​直接调用​​。发射信号的线程会​​立即、直接​​调用槽函数。​​这就像同步函数调用一样​​，槽函数在信号线程中执行。
​​Qt::QueuedConnection​​： ​​队列连接​​。信号发射时，槽函数的调用会被封装成一个​​事件（QEvent）​​，并放入接收者对象所在线程的​​事件循环（Event Loop）​​ 中等待处理。接收者线程的事件循环会在未来某个时刻取出这个事件并执行槽函数。​​这是实现跨线程通信的核心​​。
​​Qt::BlockingQueuedConnection​​： 阻塞队列连接。类似 QueuedConnection，但信号发射线程会​​阻塞​​，直到接收者线程的槽函数执行完毕。使用时必须小心死锁。
​​Qt::UniqueConnection​​： 可以和以上类型用 |组合，确保同一个信号和槽之间只有一个连接。
跨线程通信示例​​：
// Worker 对象在 workerThread 线程中
Worker *worker = new Worker;
QThread *workerThread = new QThread;
worker->moveToThread(workerThread);
workerThread->start();

// 主线程中的对象连接 worker 的信号
// 由于对象在不同线程，默认使用 Qt::QueuedConnection
connect(worker, &Worker::resultReady, this, &MainWindow::handleResult);

// 当 worker 发射 resultReady 信号时
// handleResult 槽的调用会被放入主线程的事件队列
// 由主线程的事件循环在合适的时候执行，从而保证了线程安全。

Qt 的信号槽机制是一种通过 ​​moc 元对象编译器​​在 C++ 基础上实现的​​高级通信框架​​。它的核心思想是​​发布-订阅​​，通过​​内省​​来动态查找和调用函数，并巧妙地利用​​事件循环​​来实现跨线程通信。虽然比直接回调函数调用有轻微的性能开销，但它带来的​​类型安全、松散耦合和开发效率​​的巨大提升，使其成为 Qt 框架最成功和最受欢迎的特性之一。

