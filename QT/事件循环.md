事件循环是 GUI 应用程序乃至所有异步程序的核心。它提供了一个​​循环​​，不断地从事件队列中取出事件并进行处理，直到程序退出。
1. 是什么？
它是一个由 QCoreApplication（或 QApplication）管理的无限循环，其核心工作是“等待事件发生”并“分发事件给相应的对象处理”。
2. 核心流程：
int QCoreApplication::exec()启动了事件循环。其伪代码逻辑如下：
// 伪代码，解释事件循环 (QEventLoop) 在做什么
while (!app_should_quit) {
    // 1. 等待事件发生（如果没有事件，线程会在这里休眠，不消耗CPU）
    waitUntilEventsAreAvailable();

    // 2. 从事件队列中获取一个事件
    QEvent *event = getNextEventFromTheQueue();

    // 3. 将事件分发给正确的目标 QObject
    //    (例如：鼠标点击事件会发给对应的QWidget，定时器事件会发给启动定时器的QObject)
    dispatchEvent(event);

    // 4. 处理已完成的事件，进行清理
    cleanUp();
}

3. 事件来源：
​​用户输入​​： 鼠标点击、移动，键盘按键等。
​​窗口系统​​： 窗口需要重绘（QPaintEvent）、调整大小等。
​​网络/IO​​： 网络数据包到达、文件读写完成。
​​定时器​​： QTimer超时。
​​其他线程​​： 通过 QueuedConnection发出的信号调用、QMetaObject::invokeMethod等。

总结：三大机制的协同工作
我们可以用一个比喻来理解这三者的关系：
​​元对象系统​​ 像是整个工厂的 ​​“人事部和档案库”​​。
它知道每个工人（对象）的详细信息（类名、能力、联系方式）。
它为信号和槽提供了“花名册”，让它们能找到彼此。
​​信号与槽​​ 像是工厂里的 ​​“内部通信系统”​​。
一个车间（对象）可以通过广播（发射信号）发出通知。
其他感兴趣的车间（对象）可以订阅（连接）这个广播，并在收到通知后执行相应的操作（调用槽函数）。
这个通信系统的人事信息全靠“人事部”（元对象系统）提供。
​​事件循环​​ 像是工厂的 ​​“中央调度中心”​​ 和 ​​“传送带”​​。
它永不停止地运行。
它接收来自外部（用户、网络）和内部（其他线程的信号）的“订单”（事件）。
它根据订单的类型，查阅“人事部”（元对象系统）的信息，找到合适的工人（对象），并通过“内部通信系统”（信号槽）或直接派工（调用事件处理函数）的方式让工人去处理订单。
​​三者缺一不可，共同造就了 Qt 强大、灵活且易于开发的特性。​​ 没有元对象系统，信号槽和动态属性就无法实现；没有信号槽，对象间通信将变得复杂且耦合；没有事件循环，GUI 程序将无法响应用户操作，异步和跨线程通信也将难以实现。
